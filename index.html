<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Ice Tetris</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #87ceeb 100%);
      font-family: 'Orbitron', monospace;
      color: white; overflow: hidden; position: relative;
    }
    body::before {
      content: ''; position: absolute; inset: 0;
      background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="20" cy="20" r="2" fill="white" opacity="0.3"/><circle cx="80" cy="40" r="1" fill="white" opacity="0.4"/><circle cx="40" cy="80" r="1.5" fill="white" opacity="0.2"/></svg>');
      animation: snowfall 20s linear infinite;
    }
    @keyframes snowfall { from { transform: translateY(-100vh); } to { transform: translateY(100vh); } }

    .title {
      position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
      font-size: 3em; font-weight: 900; color: #87ceeb; text-shadow: 0 0 20px rgba(135,206,235,1); z-index: 2;
    }

    .game-container {
      display: flex; justify-content: center; align-items: flex-start;
      min-height: 100vh; gap: 20px; position: relative; z-index: 1; padding-top: 100px;
    }

    .game-board {
      background: rgba(255,255,255,0.1); border: 3px solid rgba(135,206,235,0.8);
      border-radius: 15px; padding: 20px; backdrop-filter: blur(10px);
      box-shadow: 0 0 30px rgba(135,206,235,0.5); position: relative;
    }

    #gameCanvas {
      border: 2px solid rgba(255,255,255,0.3); border-radius: 10px; background: rgba(0,0,0,0.2);
      box-shadow: inset 0 0 20px rgba(135,206,235,0.3);
    }

    .game-info {
      background: rgba(255,255,255,0.1); border: 2px solid rgba(135,206,235,0.6);
      border-radius: 15px; padding: 20px; backdrop-filter: blur(10px);
      min-width: 220px; box-shadow: 0 0 20px rgba(135,206,235,0.3);
    }

    .score, .level, .lines { margin-bottom: 12px; font-weight: bold; text-shadow: 0 0 10px rgba(135,206,235,0.8); }
    .score span, .level span, .lines span { color:#87ceeb; font-size:1.2em; }

    .controls { margin-top: 16px; font-size:0.9em; opacity:0.9; }
    .controls h3 { margin-bottom: 8px; color:#87ceeb; }

    .btn-row { display:flex; gap:10px; margin:14px 0 6px; flex-wrap: wrap; }
    .btn {
      background: linear-gradient(45deg, #1e3c72, #2a5298);
      border: 2px solid #87ceeb; color: white; padding: 10px 14px; border-radius: 10px;
      cursor: pointer; font-family: 'Orbitron', monospace; font-weight: 700; font-size: 0.95em;
      transition: all 0.25s; user-select: none;
    }
    .btn:hover { background: linear-gradient(45deg,#2a5298,#87ceeb); box-shadow:0 0 14px rgba(135,206,235,0.8); transform: translateY(-1px); }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; transform:none; box-shadow:none; }

    .game-over, .paused {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.9); padding: 32px; border-radius: 20px; text-align: center;
      border: 3px solid #87ceeb; box-shadow: 0 0 50px rgba(135,206,235,0.8); display: none;
    }
    .game-over h2, .paused h2 { color:#87ceeb; margin-bottom: 12px; font-size: 2em; text-shadow: 0 0 15px rgba(135,206,235,1); }

    /* Mobile */
    @media (max-width: 768px) {
      .game-container { flex-direction: column; padding: 10px; gap: 10px; padding-top: 80px; }
      #gameCanvas { width: 250px; height: 500px; }
      .title { font-size: 2em; position: fixed; top: 10px; }
      .game-info { min-width: 250px; }
    }
  </style>
</head>
<body>
  <h1 class="title">❄️ ICE TETRIS ❄️</h1>

  <div class="game-container">
    <div class="game-board">
      <!-- tabindex makes canvas focusable -->
      <canvas id="gameCanvas" width="300" height="600" tabindex="0"></canvas>

      <!-- Overlays -->
      <div class="paused" id="pausedOverlay">
        <h2>Paused</h2>
        <p>Press Resume or hit <strong>P</strong></p>
      </div>

      <div class="game-over" id="gameOver">
        <h2>Game Over!</h2>
        <p>Final Score: <span id="finalScore">0</span></p>
        <br/>
        <button class="btn" id="restartBtnOverlay">Play Again ❄️</button>
      </div>
    </div>

    <div class="game-info">
      <div class="score">Score: <span id="score">0</span></div>
      <div class="level">Level: <span id="level">1</span></div>
      <div class="lines">Lines: <span id="lines">0</span></div>

      <div class="btn-row">
        <button class="btn" id="startBtn">Start</button>
        <button class="btn" id="pauseBtn" disabled>Pause</button>
        <button class="btn" id="restartBtn" disabled>Restart</button>
      </div>

      <div class="controls">
        <h3>❄️ Controls</h3>
        <div>← → Move</div>
        <div>↓ Soft Drop</div>
        <div>↑ Rotate</div>
        <div>Space: Hard Drop</div>
        <div>P: Pause/Resume</div>
      </div>
    </div>
  </div>

  <script>
    // DOM
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreElement = document.getElementById('score');
    const levelElement = document.getElementById('level');
    const linesElement = document.getElementById('lines');
    const gameOverElement = document.getElementById('gameOver');
    const finalScoreElement = document.getElementById('finalScore');
    const pausedOverlay = document.getElementById('pausedOverlay');

    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const restartBtn = document.getElementById('restartBtn');
    const restartBtnOverlay = document.getElementById('restartBtnOverlay');

    // Game constants
    const ROWS = 20, COLS = 10, BLOCK_SIZE = 30;

    const COLORS = ['#87ceeb','#4682b4','#b0e0e6','#add8e6','#00bfff','#1e90ff','#6495ed'];

    const PIECES = [
      [[1,1,1,1]],                // I
      [[1,1],[1,1]],              // O
      [[0,1,0],[1,1,1]],          // T
      [[0,1,1],[1,1,0]],          // S
      [[1,1,0],[0,1,1]],          // Z
      [[1,0,0],[1,1,1]],          // J
      [[0,0,1],[1,1,1]]           // L
    ];

    // State
    let board = [];
    let currentPiece = null;
    let gameRunning = false;
    let isPaused = false;

    let score = 0, level = 1, lines = 0;
    let dropCounter = 0, dropInterval = 1000;
    let lastTime = 0;

    // Focus helper
    function focusCanvas() {
      setTimeout(() => canvas.focus(), 0);
    }

    // Init board
    function initBoard() {
      board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
    }

    function createPiece() {
      const typeId = Math.floor(Math.random() * PIECES.length);
      return {
        shape: PIECES[typeId].map(row => row.slice()),
        x: Math.floor(COLS / 2) - Math.floor(PIECES[typeId][0].length / 2),
        y: 0,
        color: COLORS[typeId]
      };
    }

    function drawBlock(x, y, color) {
      const gradient = ctx.createLinearGradient(x, y, x + BLOCK_SIZE, y + BLOCK_SIZE);
      gradient.addColorStop(0, color);
      gradient.addColorStop(0.5, 'rgba(255,255,255,0.3)');
      gradient.addColorStop(1, color);
      ctx.fillStyle = gradient;
      ctx.fillRect(x, y, BLOCK_SIZE, BLOCK_SIZE);

      ctx.strokeStyle = 'rgba(255,255,255,0.6)';
      ctx.lineWidth = 1;
      ctx.strokeRect(x, y, BLOCK_SIZE, BLOCK_SIZE);

      ctx.strokeStyle = 'rgba(255,255,255,0.4)';
      ctx.strokeRect(x + 2, y + 2, BLOCK_SIZE - 4, BLOCK_SIZE - 4);
    }

    function drawBoard() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (board[r][c]) drawBlock(c * BLOCK_SIZE, r * BLOCK_SIZE, board[r][c]);
        }
      }
    }

    function drawPiece(piece) {
      for (let r = 0; r < piece.shape.length; r++) {
        for (let c = 0; c < piece.shape[r].length; c++) {
          if (piece.shape[r][c]) {
            drawBlock((piece.x + c) * BLOCK_SIZE, (piece.y + r) * BLOCK_SIZE, piece.color);
          }
        }
      }
    }

    function isValidMove(piece, dx, dy, rotation) {
      const shape = rotation || piece.shape;
      const newX = piece.x + dx;
      const newY = piece.y + dy;

      for (let r = 0; r < shape.length; r++) {
        for (let c = 0; c < shape[r].length; c++) {
          if (shape[r][c]) {
            const x = newX + c;
            const y = newY + r;
            if (x < 0 || x >= COLS || y >= ROWS || (y >= 0 && board[y][x])) return false;
          }
        }
      }
      return true;
    }

    function rotatePiece(piece) {
      const rotated = [];
      for (let i = 0; i < piece.shape[0].length; i++) {
        rotated[i] = [];
        for (let j = piece.shape.length - 1; j >= 0; j--) {
          rotated[i][piece.shape.length - 1 - j] = piece.shape[j][i];
        }
      }
      return rotated;
    }

    function placePiece(piece) {
      for (let r = 0; r < piece.shape.length; r++) {
        for (let c = 0; c < piece.shape[r].length; c++) {
          if (piece.shape[r][c]) {
            if (piece.y + r < 0) { gameOver(); return; }
            board[piece.y + r][piece.x + c] = piece.color;
          }
        }
      }
    }

    function clearLines() {
      let linesCleared = 0;
      for (let r = ROWS - 1; r >= 0; r--) {
        if (board[r].every(cell => cell !== 0)) {
          board.splice(r, 1);
          board.unshift(new Array(COLS).fill(0));
          linesCleared++;
          r++;
        }
      }
      if (linesCleared > 0) {
        lines += linesCleared;
        score += linesCleared * 100 * level;
        level = Math.floor(lines / 10) + 1;
        dropInterval = Math.max(100, 1000 - (level - 1) * 100);
        updateDisplay();
      }
    }

    function updateDisplay() {
      scoreElement.textContent = score;
      levelElement.textContent = level;
      linesElement.textContent = lines;
    }

    function gameOver() {
      gameRunning = false;
      isPaused = false;
      finalScoreElement.textContent = score;
      gameOverElement.style.display = 'block';
      pauseBtn.disabled = true;
      pauseBtn.textContent = 'Pause';
    }

    // ---- Buttons ----
    function startGame() {
      if (gameRunning) return;
      initBoard();
      score = 0; level = 1; lines = 0;
      dropInterval = 1000; dropCounter = 0; lastTime = 0;
      currentPiece = createPiece();
      updateDisplay();

      gameOverElement.style.display = 'none';
      pausedOverlay.style.display = 'none';

      gameRunning = true;
      isPaused = false;

      startBtn.disabled = true;
      pauseBtn.disabled = false;
      restartBtn.disabled = false;

      requestAnimationFrame(gameLoop);
      focusCanvas(); // keep keys working
    }

    function togglePause() {
      if (!gameRunning) return;
      isPaused = !isPaused;
      pausedOverlay.style.display = isPaused ? 'block' : 'none';
      pauseBtn.textContent = isPaused ? 'Resume' : 'Pause';
      if (!isPaused) { lastTime = 0; focusCanvas(); } // refocus on resume
    }

    function restartGame() {
      gameOverElement.style.display = 'none';
      startBtn.disabled = true;
      pauseBtn.disabled = false;
      pauseBtn.textContent = 'Pause';
      restartBtn.disabled = false;

      initBoard();
      score = 0; level = 1; lines = 0;
      dropInterval = 1000; dropCounter = 0; lastTime = 0;
      currentPiece = createPiece();
      updateDisplay();

      gameRunning = true;
      isPaused = false;
      pausedOverlay.style.display = 'none';

      requestAnimationFrame(gameLoop);
      focusCanvas();
    }

    // ---- Main loop with delta-time fix ----
    function gameLoop(timestamp = 0) {
      if (!gameRunning) return;

      if (lastTime === 0) lastTime = timestamp;
      const delta = timestamp - lastTime;
      lastTime = timestamp;

      if (!isPaused) {
        dropCounter += delta;
        if (dropCounter > dropInterval) {
          if (currentPiece && isValidMove(currentPiece, 0, 1)) {
            currentPiece.y++;
          } else if (currentPiece) {
            placePiece(currentPiece);
            clearLines();
            currentPiece = createPiece();
            if (!isValidMove(currentPiece, 0, 0)) {
              gameOver();
              return;
            }
          }
          dropCounter = 0;
        }
      }

      drawBoard();
      if (currentPiece) drawPiece(currentPiece);

      requestAnimationFrame(gameLoop);
    }

    // ---- Keyboard controls ----
    document.addEventListener('keydown', (e) => {
      // Prevent browser handling for our keys
      if (['ArrowLeft','ArrowRight','ArrowDown','ArrowUp',' ','p','P'].includes(e.key)) {
        e.preventDefault();
      }

      // Global pause toggle
      if (e.key === 'p' || e.key === 'P') {
        togglePause();
        return;
      }

      if (!gameRunning || isPaused || !currentPiece) return;

      switch (e.key) {
        case 'ArrowLeft':
          if (isValidMove(currentPiece, -1, 0)) currentPiece.x--;
          break;
        case 'ArrowRight':
          if (isValidMove(currentPiece, 1, 0)) currentPiece.x++;
          break;
        case 'ArrowDown':
          if (isValidMove(currentPiece, 0, 1)) {
            currentPiece.y++; score += 1; updateDisplay();
          }
          break;
        case 'ArrowUp': {
          const rotated = rotatePiece(currentPiece);
          if (isValidMove(currentPiece, 0, 0, rotated)) currentPiece.shape = rotated;
          break;
        }
        case ' ':
          while (isValidMove(currentPiece, 0, 1)) {
            currentPiece.y++; score += 2;
          }
          updateDisplay();
          break;
      }
    }, { passive: false });

    // ---- Touch controls ----
    let touchStartX = 0, touchStartY = 0;
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    });

    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      if (!gameRunning || isPaused || !currentPiece) return;

      const touchEndX = e.changedTouches[0].clientX;
      const touchEndY = e.changedTouches[0].clientY;

      const diffX = touchStartX - touchEndX;
      const diffY = touchStartY - touchEndY;

      if (Math.abs(diffX) > 30 || Math.abs(diffY) > 30) {
        if (Math.abs(diffX) > Math.abs(diffY)) {
          if (diffX > 0) { if (isValidMove(currentPiece, -1, 0)) currentPiece.x--; }
          else { if (isValidMove(currentPiece, 1, 0)) currentPiece.x++; }
        } else {
          if (diffY < 0) {
            while (isValidMove(currentPiece, 0, 1)) { currentPiece.y++; score += 2; }
            updateDisplay();
          } else {
            const rotated = rotatePiece(currentPiece);
            if (isValidMove(currentPiece, 0, 0, rotated)) currentPiece.shape = rotated;
          }
        }
      } else {
        const rotated = rotatePiece(currentPiece);
        if (isValidMove(currentPiece, 0, 0, rotated)) currentPiece.shape = rotated;
      }
    });

    // ---- Wire buttons (blur to avoid sticky focus) ----
    startBtn.addEventListener('click', () => { startGame(); startBtn.blur(); focusCanvas(); });
    pauseBtn.addEventListener('click', () => { togglePause(); pauseBtn.blur(); if (!isPaused) focusCanvas(); });
    restartBtn.addEventListener('click', () => { restartGame(); restartBtn.blur(); focusCanvas(); });
    restartBtnOverlay.addEventListener('click', () => { restartGame(); restartBtnOverlay.blur(); focusCanvas(); });

    // ---- Initial setup (do not auto-start) ----
    initBoard();
    drawBoard();
    updateDisplay();
  </script>
</body>
</html>
